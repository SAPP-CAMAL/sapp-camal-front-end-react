name: Admin Frontend CD (No Docker)

on:
  push:
    branches:
      - prod-ruminahui

permissions:
  contents: read

jobs:
  build:
    name: Build Next.js app
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Use Node.js 20
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      # PASO 1: Crear .env para el Build (Vital para NEXT_PUBLIC_*)
      - name: Create .env file for Build
        run: |
          echo "${{ secrets.ENV_FILE }}" | base64 -d > .env

      - name: Install dependencies
        run: npm ci

      - name: Build
        # Ya no necesitamos pasar variables 'env' aquÃ­ manuales,
        # Next las leerÃ¡ del archivo .env que acabamos de crear.
        run: npm run build

      # Comprimimos .next, public y config files necesarios
      - name: Compress Build
        run: tar -czf build.tar.gz .next public next.config.ts package.json package-lock.json ecosystem.config.js

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: app-build
          path: build.tar.gz

  deploy:
    name: Deploy to Server
    needs: build
    runs-on: ubuntu-latest
    environment: RUMINAHUI
    steps:
      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: app-build

      - name: Transfer Build to Server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USERNAME }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_PORT || 22 }}
          source: "build.tar.gz"
          target: "${{ secrets.APP_DIR }}"

      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.2.0
        env:
          # Inyectamos el secreto para decodificarlo dentro del servidor
          ENV_FILE: ${{ secrets.ENV_FILE }}
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USERNAME }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_PORT || 22 }}
          envs: ENV_FILE
          script: |
            export NVM_DIR="$HOME/.nvm"
            [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
            
            node -v

            set -euo pipefail
            
            APP_DIR="${{ secrets.APP_DIR }}"
            mkdir -p "$APP_DIR"
            cd "$APP_DIR"

            # PASO 2: Crear .env en el Servidor (Vital para PM2 y PORT)
            echo "$ENV_FILE" | base64 -d > .env
            
            # Descomprimir la nueva versiÃ³n
            if [ -f "build.tar.gz" ]; then
              # Limpiamos carpeta anterior de build
              rm -rf .next
            
              # Descomprimimos
              tar -xzf build.tar.gz
              rm build.tar.gz
            else
              echo "âŒ Error: No se encontrÃ³ el archivo build.tar.gz"
              exit 1
            fi
            
            # Instalar dependencias de producciÃ³n (mucho mÃ¡s rÃ¡pido)
            npm ci --omit=dev
            
            # Iniciar o Recargar PM2
            echo "Reiniciando aplicaciÃ³n..."
            
            # Verificar si PM2 estÃ¡ inicializado
            if ! command -v pm2 &> /dev/null; then
              npm install -g pm2
              pm2 install pm2-logrotate
            fi
            
            # Usar startOrRestart para manejar tanto primer deploy como actualizaciones
            pm2 startOrRestart ecosystem.config.js --update-env
            
            pm2 save
            pm2 status
            echo "ðŸš€ Despliegue completado."